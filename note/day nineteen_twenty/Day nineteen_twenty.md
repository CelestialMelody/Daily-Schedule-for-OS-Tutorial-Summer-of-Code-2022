# Day nineteen_twenty

### 多道程序与分时任务

- 操作系统在性能上的一系列功能改进：

  - 通过 **提前加载应用程序到内存**，减少应用程序切换开销

  - 通过 **协作机制** 支持程序主动放弃处理器，提高系统执行效率

  - 通过 **抢占机制** 支持程序被动放弃处理器，提高不同程序对处理器资源使用的公平性，也进一步提高了应用对 I/O 事件的响应效率

>批处理操作系统
>
>- 首先，它能够**自动按照顺序加载并运行**序列中的每一个应用，当一个应用运行结束之后无需操作员的手动替换
>- 另一方面，在**硬件级特权隔离机制**的帮助下，运行在更高特权级的操作系统不会受到有意或者无意出错的应用的影响
>- 在**硬件异常触发机制**的帮助下，可以全方位监控运行在用户态低特权级的应用执行，一旦应用越过了特权级界限或主动申请获得操作系统的服务，就会触发 Trap 并进入到批处理系统中进行处理
>- 无论原因是应用出错或是应用声明自己执行完毕，批处理系统都只需要加载应用序列中的下一个应用并让其执行
>- 可以看到批处理系统的特性是：**在内存中同一时间最多只需驻留一个应用**。这是因为只有当一个应用出错或退出之后，批处理系统才会去将另一个应用加载到相同的一块内存区域

- 多道程序（Multiprogramming）

  - 内存中尽量同时驻留多个应用，处理器的利用率提高
  - 但只有一个程序执行完毕后或主动放弃执行，处理器才能执行另外一个程序

- 协作式操作系统

  >- 在 多道程序 运行方式下，一个程序如果不让出处理器，其他程序是无法执行的
  >- 如果一个应用由于 I/O 操作让处理器空闲下来或让处理器忙等，那其他需要处理器资源进行计算的应用还是没法使用空闲的处理器资源

  - 让应用在执行 I/O 操作或空闲时，可以主动 **释放/放弃处理器** ，让其他应用继续执行
  - **放弃处理器** 的操作算是一种对处理器资源的直接管理，所以**应用程序可以发出放弃处理器系统调用**，让操作系统来具体完成

- 抢占式操作系统

  >- 应用不一定主动释放处理器

  - 系统的层面，提供 **强制打断应用程序的执行** 的方法，来提高整个系统的效率，让在整个系统中执行的多个程序之间占用计算机资源的情况相对公平一些
  - **分时共享（Time Sharing）** 或 **抢占式多任务（Multitasking）** —— **分时多任务** 
    - 外设可以通过硬件中断机制来与处理机进行 I/O 交互操作，提高 I/O 效率；硬件中断机制可随时打断应用程序的执行，并让操作系统来完成对外设的 I/O 响应
    - 操作系统可进一步利用某种以固定时长为时间间隔的外设中断（比如时钟中断）来强制打断一个程序的执行，这样一个程序只能运行一段时间（可以简称为一个 **时间片** , Time Slice）就一定会让出处理器，且操作系统可以在处理外设的 I/O 响应后，让不同应用程序分时占用处理器执行，并可通过统计程序占用处理器的总执行时间，来评估运行的程序对处理器资源的消耗。

  - 一个程序的一次完整执行过程称为一次 **任务** (Task)
  - 一个程序在一个时间片（Time Slice）上占用处理器执行的过程称为一个 **任务片** (Task Slice)
  - 操作系统对不同程序的执行过程中的 **任务片** 进行调度和管理，即通过平衡各个程序在整个时间段上的任务片数量，就能达到一定程度的系统公平和高效的系统效率
  - 在一个包含多个时间片的时间段上，会有属于不同程序的多个任务片在轮流占用处理器执行，这样的操作系统就是支持 **分时多任务** 或 **抢占式多任务** 的抢占式操作系统

>**批处理与多道程序的区别是什么？**
>
>对于批处理系统而言，它在一段时间内可以处理一批程序，但 **内存中只放一个程序，处理器一次只能运行一个程序，只有在一个程序运行完毕后再把另外一个程序调入内存，并执行。即 **批处理系统不能交错执行多个程序**。
>
>对于支持多道程序的系统而言，它在一段时间内也可以处理一批程序，但 **内存中可以放多个程序** ，一个程序在执行过程中，**可以主动（协作式）或被动（抢占式）地放弃自己的执行，让另外一个程序执行**。即支持多道程序的系统可以交错地执行多个程序，这样系统的利用率会更高。

#### 多道程序放置与加载

`loader` 子模块：应用的加载这部分功能

`task` 子模块：应用的执行和切换功能

**多道程序放置**

- `build.py`：针对每个应用程序修改链接脚本 `linker.ld` 中的 `BASE_ADDRESS` ，让编译器在编译不同应用时用到的 `BASE_ADDRESS` 都不同，且有足够大的地址间隔

**多道程序加载**

- `loader` 子模块的 `load_apps` 函数
- `get_base_i` 函数计算地址`base_i`
  - 第 `i` 个应用被加载到以物理地址 `base_i` 开头的一段物理内存上

#### 任务切换

>当程序访问 I/O 外设或睡眠时，其实是不需要占用处理器的
>
>把应用程序在不同时间段的执行过程分为两类
>
>- 占用处理器执行有效任务的计算阶段
>- 不必占用处理器的等待阶段

>应用程序的一次执行过程（也是一段控制流）称为一个 **任务** 
>
>应用执行过程中的一个时间片段上的执行片段或空闲片段称为 “**计算任务片**” 或 “**空闲任务片**” 

>任务的执行“暂停”和“继续”——控制流切换的机制——让程序执行的状态（也称 **上下文** ），即在执行过程中同步变化的资源（如寄存器、栈等）保持不变，或者变化在它的预期之内
>
>需要保存与恢复的资源被称为 **任务上下文 (Task Context)** 
>
>- 只有那些 **对于程序接下来的正确执行** 仍然有用，且在它 **被切换出去的时候有被覆盖风险** 的那些资源才有被保存的价值



**不同类型的上下文与切换**

>[函数调用与栈](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/5support-func-call.html#term-function-call-and-stack)：为了支持嵌套函数调用，不仅需要硬件平台提供特殊的跳转指令，还需要保存和恢复 [函数调用上下文](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/5support-func-call.html#term-function-context) 

>“批处理系统”中 —— 异常（Trap）控制流，即两条控制流的特权级切换，需要保存和恢复 [系统调用（Trap）上下文](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/4trap-handling.html#term-trap-context) —— 切换特权级别、内核栈与用户栈、保存寄存器值 —— 让内核能够完全掌控应用的执行，且不会被应用破坏整个系统，利用硬件提供的特权级机制，让应用和内核运行在不同的特权级 



**任务切换**

- 任务切换是来自两个不同应用在内核中的 Trap 控制流之间的切换

- 与 Trap 切换进行比较

  - 与 Trap 切换不同，它不涉及特权级切换

  - 与 Trap 切换不同，它的一部分是由编译器帮忙完成的

  - 与 Trap 切换相同，它对应用是透明的

>​	当一个应用 Trap 到 S 模式的操作系统内核中进行进一步处理（即进入了操作系统的 Trap 控制流）的时候，其 Trap 控制流可以调用一个特殊的 `__switch` 函数。
>​	这个函数表面上就是一个普通的函数调用：在 `__switch` 返回之后，将继续从调用该函数的位置继续向下执行。
>​	但是其间却隐藏着复杂的控制流切换过程。
>​	具体来说，调用 `__switch` 之后直到它返回前的这段时间，原 Trap 控制流 *A* 会先被暂停并被切换出去， CPU 转而运行另一个应用在内核中的 Trap 控制流 *B* 。
>​	然后在某个合适的时机，原 Trap 控制流 *A* 才会从某一条 Trap 控制流 *C* （很有可能不是它之前切换到的 *B* ）切换回来继续执行并最终返回。
>​	不过，从实现的角度讲， `__switch` 函数和一个普通的函数之间的核心差别仅仅是它会 **换栈** 

>​	当 Trap 控制流准备调用 `__switch` 函数使任务从运行状态进入暂停状态的时候，让我们考察一下它内核栈上的情况。
>
>​	在准备调用 `__switch` 函数之前，内核栈上从栈底到栈顶分别是保存了应用执行状态的 Trap 上下文以及内核在对 Trap 处理的过程中留下的调用栈信息。
>
>​	由于之后还要恢复回来执行，我们必须保存 CPU 当前的某些寄存器，我们称它们为 **任务上下文** (Task Context)。
>
>​	至于上下文保存的位置，在任务管理器 `TaskManager` 里面能找到一个数组 `tasks` ，其中的每一项都是一个任务控制块即 `TaskControlBlock` ，它负责保存一个任务的状态，而任务上下文 `TaskContext` 被保存在任务控制块中。
>
>​	在内核运行时我们会初始化 `TaskManager` 的全局实例 `TASK_MANAGER` ，因此所有任务上下文实际保存在在 `TASK_MANAGER` 中，从内存布局来看则是放在内核的全局数据 `.data` 段中。
>
>​	当要从其他任务切换回来继续执行这个任务的时候，CPU 会读取同样的位置并从中恢复任务上下文。



`os3/src/task/mod.rs`

- 对于当前正在执行的任务的 Trap 控制流，用 `current_task_cx_ptr` 变量来保存放置当前任务上下文的地址
- 用 `next_task_cx_ptr` 的变量来保存放置下一个要执行任务的上下文的地址



`os3/src/task/switch.rs` `os3/src/task/switch.S `

>Trap 控制流在调用 `__switch` 之前就需要明确知道即将切换到哪一条目前正处于暂停状态的 Trap 控制流，因此 `__switch` 有两个参数，第一个参数代表它自己，第二个参数则代表即将切换到的那条 Trap 控制流
>
>这里我们用上面提到过的 `current_task_cx_ptr` 和 `next_task_cx_ptr` 作为代表
>
>假设某次 `__switch` 调用要从 Trap 控制流 A 切换到 B，一共可以分为四个阶段
>
>- 阶段 [1]：在 Trap 控制流 A 调用 `__switch` 之前，A 的内核栈上只有 Trap 上下文和 Trap 处理函数的调用栈信息，而 B 是之前被切换出去的
>- 阶段 [2]：A 在 A 任务上下文空间在里面保存 CPU 当前的寄存器快照
>- 阶段 [3]：这一步极为关键，读取 `next_task_cx_ptr` 指向的 B 任务上下文，根据 B 任务上下文保存的内容来恢复 `ra` 寄存器、`s0~s11` 寄存器以及 `sp` 寄存器。只有这一步做完后， `__switch` 才能做到一个函数跨两条控制流执行，即 *通过换栈也就实现了控制流的切换* 
>- 阶段 [4]：上一步寄存器恢复完成后，可以看到通过恢复 `sp` 寄存器换到了任务 B 的内核栈上，进而实现了控制流的切换。这就是为什么 `__switch` 能做到一个函数跨两条控制流执行。此后，当 CPU 执行 `ret` 汇编伪指令完成 `__switch` 函数返回后，任务 B 可以从调用 `__switch` 的位置继续向下执行
>
>从结果来看，我们看到 A 控制流 和 B 控制流的状态发生了互换， A 在保存任务上下文之后进入暂停状态，而 B 则恢复了上下文并在 CPU 上继续执行



 `os/src/task/context.rs`

- `TaskContext` 包含的寄存器
-  `ra` 记录了 `__switch` 函数返回之后应该跳转到哪里继续执行，从而在任务切换完成并 `ret` 之后能到正确的位置。
- 对于 **一般的函数** 而言，Rust/C **编译器** 会在函数的起始位置自动生成代码来**保存 `s0~s11` 这些被调用者保存的寄存器**。但 `__switch` 是一个用汇编代码写的 **特殊函数**，它不会被 Rust/C 编译器处理，所以我们需要在 `__switch` 中 **手动编写保存 `s0~s11` 的汇编代码**。
- 不用保存其它寄存器是因为：其它寄存器中，属于调用者保存的寄存器是由编译器在高级语言编写的调用函数中自动生成的代码来完成保存的；还有一些寄存器属于临时寄存器，不需要保存和恢复

>补充：[risc-v寄存器功能解析-调用规范](https://zhuanlan.zhihu.com/p/295439950) [RISC-V 架构上的 C 语言调用规范](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/5support-func-call.html#term-calling-convention)

---

#### 多道程序与协作式调度

>- 任务运行状态：任务从开始到结束执行过程中所处的不同运行状态：未初始化、准备执行、正在执行、已退出
>- 任务控制块：管理程序的执行过程的任务上下文，控制程序的执行与暂停
>- 任务相关系统调用：应用程序和操作系统直接的接口，用于程序主动暂停 `sys_yield` 和主动退出 `sys_exit`



**多道程序背景与 yield 系统调用**

- **忙等**：通常外设会提供一个可读的寄存器记录它目前的工作状态，于是 CPU 需要不断原地循环读取它直到它的结果显示设备已经将请求处理完毕了，才能继续执行
- 多道程序（“协作式”）的思想在于：内核同时管理多个应用。如果外设处理 I/O 的时间足够长，那我们可以先进行任务切换去执行其他应用；在某次切换回来之后，应用再次读取设备寄存器，发现 I/O 请求已经处理完毕了，那么就可以根据返回的 I/O 结果继续向下执行了。这样的话，只要同时存在的应用足够多，就能一定程度上隐藏 I/O 外设处理相对于 CPU 的延迟，保证 CPU 不必浪费时间在等待外设上，而是几乎一直在进行计算。
- 这种任务切换，是让应用 **主动** 调用 `sys_yield` 系统调用来实现的，这意味着应用主动交出 CPU 的使用权给其他应用



>**sys_yield 的缺点**
>
>当应用调用它主动交出 CPU 使用权之后，它下一次再被允许使用 CPU 的时间点与内核的调度策略与当前的总体应用执行情况有关，很有可能远远迟于该应用等待的事件（如外设处理完请求）达成的时间点，这就会造成该应用的响应延迟不稳定或者很长



`user/src/syscall.rs`

- pub fn yield_() (`yield` 是 Rust 的关键字，因此我们只能将应用直接调用的接口命名为 `yield_`)



**任务控制块与任务运行状态**

- `pub enum TaskStatus` 

- 任务控制块 (Task Control Block) `pub struct TaskControlBlock`



**任务管理器**

- 一个全局的任务管理器来管理这些用任务控制块描述的应用
- `os3/src/task/mod.rs` `pub struct TaskManager` `struct TaskManagerInner`
- 初始化 `TaskManager` 的全局实例 `TASK_MANAGER`；`os/src/task/mod.rs`



[实现 sys_yield 和 sys_exit 系统调用](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/3multiprogramming.html#sys-yield-sys-exit)

- `sys_yield` 表示应用自己暂时放弃对CPU的当前使用权，进入 `Ready` 状态

- `sys_exit` 表示应用退出执行，它的含义是退出当前的应用并切换到下个应用

- 在实际切换之前我们需要手动 `drop` 掉我们获取到的 `TaskManagerInner` 的来自 `UPSafeCell` 的借用标记



运行状态变化图

<img src="./pic/fsm-coop.png" alt="../_images/fsm-coop.png" style="zoom:50%;" />



[第一次进入用户态](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/3multiprogramming.html#id7)

- 调用 `init_app_cx` 构造该任务的 Trap 上下文（包括应用入口地址和用户栈指针）并将其压入到内核栈顶

- 调用 `TaskContext::goto_restore` 来构造每个任务保存在任务控制块中的任务上下文

- `rust_main` 中调用 `task::run_first_task` 来开始应用的执行
  - `__switch` 第一个参数 ` &mut _unused as *mut TaskContext；`
  - `__switch` 有两个参数分别表示当前应用和即将切换到的应用的任务上下文指针，其第一个参数存在的意义是记录当前应用的任务上下文被保存在哪里，也就是当前应用内核栈的栈顶，这样之后才能继续执行该应用。但在 `run_first_task` 的时候，我们并没有执行任何应用， `__switch` 前半部分的保存仅仅是在启动栈上保存了一些之后不会用到的数据，自然也无需记录启动栈栈顶的位置
  - 因此，显式在启动栈上分配了一个名为 `_unused` 的任务上下文，并将它的地址作为第一个参数传给 `__switch` ，这样保存一些寄存器之后的启动栈栈顶的位置将会保存在此变量中
  - 然而无论是此变量还是启动栈我们之后均不会涉及到，一旦应用开始运行，我们就开始在应用的用户栈和内核栈之间开始切换了
  - 这里声明此变量的意义仅仅是为了避免覆盖到其他数据



---

#### 分时多任务系统与抢占式调度

>- 分时多任务：操作系统管理每个应用程序，以时间片为单位来分时占用处理器运行应用
>- 时间片轮转调度：操作系统在一个程序用完其时间片后，就抢占当前程序并调用下一个程序执行，周而复始，形成对应用程序在任务级别上的时间片轮转调度

>- 吞吐量 (Throughput) —— 评判 CPU 利用率
>- 后台应用 (Background Application)
>- 交互式应用 (Interactive Application) —— 目标提高用户（应用的使用者和开发者）操作的响应速度，减少延迟（Latency）

>java 多线程：当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的 CPU 使用权

>**协作式调度** (Cooperative Scheduling)：要一个应用不主动 yield 交出 CPU 使用权，它就会一直执行下去
>
>**抢占式调度** (Preemptive Scheduling) ：应用随时都有被内核切换出去的可能

>一般将 **时间片** (Time Slice) 作为应用连续执行时长的度量单位，每个时间片可能在毫秒量级。
>
>可以从性能（主要是吞吐量和延迟两个指标）和 **公平性** (Fairness)（多个应用分到的时间片占比不应差距过大）两个维度来评价调度算法



- 时间片轮转算法 (RR, Round-Robin)：维护一个任务队列，每次从队头取出一个应用执行一个时间片，然后把它丢到队尾，再继续从队头取出一个应用，以此类推直到所有的应用执行完毕

- RISC-V 架构中的中断

  >对于某个处理器核而言， 异常与当前 CPU 的指令执行是 **同步** (Synchronous) 的，异常被触发的原因一定能够追溯到某条指令的执行；
  >
  >而中断则 **异步** (Asynchronous) 于当前正在进行的指令，也就是说中断来自于哪个外设以及中断如何触发完全与处理器正在执行的当前指令无关

  - **软件中断** (Software Interrupt)：由软件控制发出的中断

  - **时钟中断** (Timer Interrupt)：由时钟电路发出的中断

  - **外部中断** (External Interrupt)：由外设发出的中断

- 判断中断是否会被屏蔽

  - 如果中断的特权级低于 CPU 当前的特权级，则该中断会被屏蔽，不会被处理
  - 如果中断的特权级高于与 CPU 当前的特权级或相同，则需要通过相应的 CSR 判断该中断是否会被屏蔽

> **嵌套中断与嵌套 Trap**
>
> 嵌套中断可以分为两部分：在处理一个中断的过程中又被同特权级/高特权级中断所打断。默认情况下硬件会避免同特权级再次发生，但高特权级中断则是不可避免的会再次发生。
>
> 嵌套 Trap 则是指处理一个 Trap（可能是中断或异常）的过程中又再次发生 Trap ，嵌套中断是嵌套 Trap 的一个特例。在内核开发时我们需要仔细权衡哪些嵌套 Trap 应当被允许存在，哪些嵌套 Trap 又应该被禁止，这会关系到内核的执行模型。



**时钟中断与计时器**

- 操作系统内置时钟，频率一般低于 CPU 主频
- 计数器：统计处理器自上电以来经过了多少个内置时钟的时钟周期

M 特权级的 CSR 

- 在 RISC-V 64 架构上，该计数器保存在一个 64 位的 CSR `mtime` 中（无需担心它的溢出问题，在内核运行全程可以认为它是一直递增的）
- 另外一个 64 位的 CSR `mtimecmp` 的作用是：一旦计数器 `mtime` 的值超过了 `mtimecmp`，就会触发一次时钟中断 —— 通过设置 `mtimecmp` 的值来决定下一次时钟中断何时触发
- 运行在 M 特权级的 SEE （这里是RustSBI）预留了相应的接口，可以调用它们来间接实现计时器的控制



`os/src/sbi.rs`

- `set_timer` 调用，是一个由 SEE 提供的标准 SBI 接口函数，它可以用来设置 `mtimecmp` 的值

`os/src/timer.rs`

- `timer` 子模块的 `get_time` 函数可以取得当前 `mtime` 计数器的值
-  `timer` 子模块的 `set_next_trigger` 函数：触发 S 特权级时钟中断 —— 计算规定时间的增量
- 增量的计算方式
  - 常数 `CLOCK_FREQ` 是一个预先获取到的 各平台不同的 时钟频率，单位为赫兹，也就是一秒钟之内计数器的增量
  - `CLOCK_FREQ` （时钟频率，每秒时钟周期数; `这里应该是操作系统内部的时钟的时钟频率`）除以常数 `TICKS_PER_SEC` 即是下一次时钟中断的计数器增量值
  - 这里 `TICKS_PER_SEC = 100` 相当于 为了得到时钟中断周期为10ms(1s / 100) 的一个倍数

- `get_time_us` 以微秒为单位返回当前计数器的值

>评论解答：
>
>`CLOCK_FREQ`是时钟频率，而计数器也是对该时钟的时钟周期进行计数，因此`CLOCK_FREQ`也是一秒之内计数器的增量。而我们将一秒钟分为`TICKS_PER_SEC`，也即100个时间片，每个时间片10ms，那么每个时间片内计数器的增量就应该是一秒内的总体增量除以这个整体被分为的份数，所以是`CLOCK_FREQ/100`。
>
>对于这句话
>	“RISC-V 架构要求处理器要有一个内置时钟，其频率一般低于 CPU 主频”，
>	实际上在 CPU 的微架构内通常有多个不同频率的时钟源（比如各种晶振等），然后他们进行一些组合电路的处理又会得到更多不同频率的信号，不同的电路模块可能使用不同频率的时钟信号以满足同步需求。CPU 的主体流水线所采用的时钟信号的频率是 CPU 的主频，但同时还有另一个用来计时的时钟模块（也就是上面提到的时钟）运行在另一个不同的频率。他们两个的另一个区别是，CPU 的时钟周期在`mcycle`寄存器中计数，而时钟的时钟周期在`mtime`寄存器中计数，因此这是两个独立且不同的频率。

>拓展
>
>[clock ticks](https://baike.baidu.com/item/tick/1202967) （脉冲 点 时间点） 与 clock cycle（时钟周期 时间段）
>
>产生一个tick的时间（脉冲时间 晶体滴答或者震荡一次的时间）是时钟周期



**抢占式调度**

- 在 `trap_handler` 函数下新增一个条件分支跳转，当发现触发了一个 S 特权级时钟中断的时候，首先重新设置一个 10ms 的计时器，然后调用 `suspend_current_and_run_next` 函数暂停当前应用并切换到下一个

- 避免 S 特权级时钟中断被屏蔽 初始化设置

  > 没有将应用初始 Trap 上下文中的 `sstatus` 中的 `SPIE` 位置为 1 。这将意味着 CPU 在用户态执行应用的时候 `sstatus` 的 `SIE` 为 0 ，根据定义来说，此时的 CPU 会屏蔽 S 态所有中断，自然也包括 S 特权级时钟中断。
  >
  > 但是可以观察到我们的应用在用尽一个时间片之后能够正常被打断。这是因为当 CPU 在 **U 态接收到一个 S 态**时钟中断时会被抢占，这时无论 `SIE` 位是否被设置都会进入 Trap 处理流程。

  > 评论解答：
  >
  > sstatus 下的 SIE 位只控制着在 S 模式下的中断使能，如果 sstatus.SIE 标记为 0，则在 S 模式下不会响应中断；
  >
  > **但如果控制流在 U 模式下时，sstatus.SIE 位是不会影响中断响应判断的，此时任何 S 特权级的中断都会被响应。**

- 通过 yield 来优化 **轮询** (Busy Loop) 过程带来的 CPU 资源浪费

>[risc-v 寄存器](https://zhuanlan.zhihu.com/p/486528142)
>
>spie：表明在进入到S模式前，是否 S interrupt
>
>sie：S 中断使能位

---

### SBI 与 BIOS

[复制评论](http://rcore-os.cn/rCore-Tutorial-Book-v3/appendix-c/index.html) -by [denglj](http://rcore-os.cn/rCore-Tutorial-Book-v3/appendix-c/index.html)

>SBI 是 RISC-V Supervisor Binary Interface 规范的缩写，OpenSBI 是RISC-V官方用C语言开发的SBI参考实现；RustSBI 是用Rust语言实现的SBI。
>
>BIOS 是 Basic Input/Output System，作用是引导计算机系统的启动以及硬件测试，并向OS提供硬件抽象层。
>
>机器上电之后，会从ROM中读取引导代码，引导整个计算机软硬件系统的启动。而整个启动过程是分为多个阶段的，现行通用的多阶段引导模型为：
>
>ROM -> LOADER -> RUNTIME -> BOOTLOADER -> OS
>
>Loader 要干的事情，就是内存初始化，以及加载 Runtime 和 BootLoader 程序。而Loader自己也是一段程序，常见的Loader就包括 BIOS 和 UEFI，后者是前者的继任者。
>
>Runtime 固件程序是为了提供运行时服务（runtime services），它是对硬件最基础的抽象，对OS提供服务，当我们要在同一套硬件系统中运行不同的操作系统，或者做硬件级别的虚拟化时，就离不开Runtime服务的支持。SBI就是RISC-V架构的Runtime规范。
>
>BootLoader 要干的事情包括文件系统引导、网卡引导、操作系统启动配置项设置、操作系统加载等等。常见的 BootLoader 包括GRUB，U-Boot，LinuxBoot等。
>
>而 BIOS/UEFI 的大多数实现，都是 Loader、Runtime、BootLoader 三合一的，所以不能粗暴的认为 SBI 跟 BIOS/UEFI 有直接的可比性。
>
>如果把BIOS当做一个泛化的术语使用，而不是指某个具体实现的话，那么可以认为 SBI 是 BIOS 的组成部分之一。
>
>也可参考这份文稿《[An Introduction to RISC-V Boot Flow](https://riscv.org/wp-content/uploads/2019/12/Summit_bootflow.pdf)》的P5, P7, P9-11。
>
>题外话：
>计算机最重要的思想之一就是分层抽象，在任意两层之间，还可以按照设计者的意愿再次添加抽象层。而软件架构的设计和实现，是为了解决现实世界的具体问题，会面临资源、财力、物力、人力、时间等多种因素的掣肘，就会诞生一些“不那么规矩”、“不那么单纯”的架构或组件/软件，它们往往会跨层次，跨模块，大模块拆小，小模块合并，甚至打破一些“金科玉律”等等。
>
>所以，相比于弄懂一个名词，更多的精力应该放在理解事物的本质上，只要把解决问题的流程和方法弄明白了，解决问题的过程中所用到的子流程、工具、方法，你爱怎么叫怎么叫，甚至自己发明名词也可以（只是与外人沟通可能会不太顺畅）。

---

### Rust

#### unsafe

**解引用裸指针：`*const T` 和 `*mut T`**

- 可以绕过 Rust 的借用规则，可以同时拥有一个数据的可变、不可变指针，甚至还能拥有多个可变的指针

  > `unsafe` 并不能绕过 Rust 的借用检查，也不能关闭任何 Rust 的安全检查规则，例如当 `unsafe` 中使用**引用**时，该有的检查一样都不会少
  >
  > 
  >
  > 解引用裸指针可以绕过借用规则

- 并不能保证指向合法的内存

- 可以是 `null`

- 没有实现任何自动的回收 (drop)

- **创建裸指针是安全的行为，而解引用裸指针才是不安全的行为**

- 基于引用创建裸指针

- 基于内存地址创建裸指针
- 基于智能指针创建裸指针
  - 先解引用在引用 `&*`
  - 使用 into_raw 来创建
- 使用 * 解引用

- 跟 `C` 语言的代码进行交互( FFI )



**unsafe 函数或方法**

- 在 unsafe 函数体中使用 unsafe 语句块是多余的行为
- 声明与调用时加上 `unsafe`



**用安全抽象包裹 unsafe 代码**

- 一个函数包含了 `unsafe` 代码不代表需要将整个函数都定义为 `unsafe fn`
- `as_mut_ptr`



**FFI**（Foreign Function Interface）

- 在 `exetrn "C"` 代码块中，列出想要调用的外部函数的签名

- `"C"` 定义了外部函数所使用的**应用二进制接口**`ABI` (Application Binary Interface)：`ABI` 定义了如何在汇编层面来调用该函数
- 在所有 `ABI` 中，`C` 语言的是最常见的

- 在其它语言中调用 Rust 函数：`extern` 来创建一个接口，其它语言可以通过该接口来调用相关的 Rust 函数

- 注解 `#[no_mangle]`，它用于告诉 Rust 编译器：不要乱改函数的名称

  >`Mangling` 的定义是：当 Rust 因为编译需要去修改函数的名称，例如为了让名称包含更多的信息，这样其它的编译部分就能从该名称获取相应的信息，这种修改会导致函数名变得相当不可读

​	

**访问或修改一个可变的静态变量**

**实现 unsafe 特征**



**访问 [union](https://doc.rust-lang.org/reference/items/unions.html) 中的字段**

- 主要用于跟 `C` 代码进行交互
- 访问 `union` 的字段是不安全的
  - Rust 无法保证当前存储在 `union` 实例中的数据类型
  - 所有字段都共享同一个存储空间，意味着往 `union` 的某个字段写入值，会导致其它字段的值会被覆盖



>[Copy 与 Clone —— 深拷贝与浅拷贝](https://course.rs/appendix/derive.html?highlight=clone#%E5%A4%8D%E5%88%B6%E5%80%BC%E7%9A%84-clone-%E5%92%8C-copy)
>
>- 基本数据类型的特点：直接存储在栈(stack)中的数据
>
>- 引用数据类型 —— 堆分配数据类型 —— 动态数据类型（但仍然是 [Sized 固定大小类型](https://course.rs/advance/smart-pointer/box.html#%E5%B0%86%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B%E5%8F%98%E4%B8%BA-sized-%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B) 使用rust智能指针 c指针）的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里 
>
>- 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存
>- 深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象
>
>rust
>
>- `Copy` 特征允许你通过只拷贝存储在栈上的数据来复制值(浅拷贝),而无需复制存储在堆上的底层数据
>- `Clone` 特征用于创建一个值的深拷贝（deep copy），复制过程可能包含代码的执行以及堆上数据的复制
>- 对于实现了 `Copy` 的类型，它的 `Clone` 方法应该跟 `Copy` 语义相容，等同于按位拷贝
>
>Cpp赋值和浅拷贝的区别
>
>- 当我们把一个对象 **赋值** 给一个新的变量时，赋的其实是该对象的在 **栈中的地址** ，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的
>- **浅拷贝是按位拷贝对象，它会创建一个新对象**，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源
>
>总结
>
>浅拷贝是栈上数据的复制，深拷贝是对堆上数据的复制；对于 **基本类型，栈中保存具体的值** ，故按位拷贝（浅拷贝）时，拷贝的时相同的值；对于引用类型，按位拷贝栈上数据，即浅拷贝时，拷贝的是指向堆数据的指针

---

