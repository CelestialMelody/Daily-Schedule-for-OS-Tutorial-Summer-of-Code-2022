# Day two

- 字符串的操作

  - 基本是对`mut String`进行的
  - `&str`也支持的替换：`replace`，`replacen`
  - 返回新字符串，**所有权转移**：`replace`，`relacen`，(连接)`+=`，`+`，`format`
  - &String 自动解引用为`&str`

- 使用**可变引用** **借用**所有权，原来的变量暂时失去所有权

- 区分**引用的作用域和变量的作用域**

  - 引用的作用域 `s` 从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号 `}`

- 不可变借用：借用只读权，不允许修改其引用的数据

- 可变引用：借用可写权(包括可读权)，允许修改其引用的数据

- 多个不可变引用可共存(可同时读)

- 可变引用具有排他性，在有可变引用时，不允许存在该数据的其他可变和不可变引用。同一时刻，你能拥有要么一个可变引用, 要么任意多个不可变引用

  ```rust
  fn main() {
      let mut s = String::from("hello");
  
      {
          // 可变引用
          let r1 = &mut s;
          // println!("{}", s) // 若r1 后面不再使用 所有权归还 s仍然有所有权
          // println!("{}, {}", r1, s); // r1使用时 s将所有权借给r1 s 没有所有权 报错；
          // 另一方面也说明 可变引用（或者说可变的）同时只能存在一个
          println!("{}", r1); // 此后r1不再使用 引用作用域结束 s具有所有权
          println!("{}", s); //
  
          // 不可变引用
          let r2 = &s;
          // 这部分不太会解释, 有点不理解
          
          // ###
          // 破案了，原来是println!宏展开使用的都是不可变引用
          // 使用 `{}` 来格式化输出，那对应的类型就必须实现 `Display` 特征，这里使用了不可变引用
          //###
          // 我好像只能用：两个都没有修改，只是读取，即没有-可变与不可变同时存在-来解释
          println!("{}, {}", s, r2); // r2 为不可变引用 允许使用值 s 与 r2; r2 应该也是借用了s的所有权 但是s也可以使用
          println!("{}, {}", &s, &r2); // 与上面的区别是&Strinng &&String（不知道与 &str &str 一个意思）, 上面是&String 与 String(不知道是不是与&str String一个意思) 但结果相同
  
          //尽管两个类型不一样，但是代码仍然可以工作，原因是 `&String` 会被隐式地转换成 `&str` 类型 
          
          // s = "rust".to_string(); // 修改s
          // println!("{}, {}", s, r2); // 报错-可变与不可变同时存在
  
          let mut ss = String::from("hello, ");
          ss.push_str(&s); // 仍然可用
          ss.push_str(&r2);
          
          let sss = r2; // 不可变引用可拷贝 Copy
  
          // s.push_str(&r2); // 报错， 存在可变借用与不可变借用 `pub fn push_str(&mut self, string: &str)`类似于例子中的clear
          // s.push_str(", world"); // 报错
  
          let r3 = s; // s 所有权转移
  
          // println!("{}", s); // s 没有所有权 r3 不是借用 r3变量作用域仍然在
      } //r3作用域结束
  }
  
  ```

-  `clear` 需要清空改变 `String`，因此它需要一个可变借用（利该方法的声明是 `pub fn clear(&mut self)` ，参数是对自身的可变借用 ）

- `drop` 函数并清理变量的堆内存，没有堆内存（所有权）不会调用

- `String`与`&str`转化

  ```rust
  fn main() {
      let s = String::from("hello,world!");
      // String to &str
      say_hello(&s);
      say_hello(&s[..]);
      say_hello(s.as_str());
      
      // &str to String
      let s = "hello".to_string();
  }
  
  fn say_hello(s: &str) {
      println!("{}",s);
  }
  ```

  

- raw string：`r"xxx"`，`r#"xxxx"#`，`r###"xxx"###`

- 切片是**不可变部分引用**

- 结构体更新语法跟赋值语句 = 非常相像，所以存在所有权转移的情况，但是基本类型（可以Copy）的仍然可以访问。**把结构体中具有所有权的字段转移出去后，将无法再访问该字段，但是可以正常访问其它的字段**

- 元组结构体(Tuple Struct) 与 单元结构体(Unit-like Struct)

- 结构体数据的所有权：**使用**了自身**拥有所有权**的 String 类型而不是基于引用的 &str 字符串切片类型——想要这个结构体拥有它所有的数据，而不是从其它地方借用数据。如果想在结构体中使用一个**引用**，就必须加上**生命周期**，否则就会报错。

- 使用 `#[derive(Debug)]` 来打印结构体的信息
  - 结构体不默认实现 `Display` 特征；使用 `{}` 来格式化输出，那对应的类型就必须实现 `Display` 特征（）；如果要用 `{}` 的方式打印结构体，那就自己实现 `Display` 特征
  - 可以使用``#[derive(Debug)]`+`{:?}` （或者`{:#?}`）
  
- `[i32]` 和 `str` 都是切片类型，但是直接使用它们会造成编译错误。为了解决，需要使用切片的引用： `&[i32]`, `&str`

- **默认使用切片来特指切片引用**。一个切片引用占用了2个字大小的内存空间，切片的第一个字是指向数据的指针（与usize类型大小相同），第二个字是切片的长度（usize类型）。字的大小取决于处理器架构。

- 切片( 引用 )可以用来借用数组的某个连续的部分，对应的签名是 `&[T]`；与数组的签名 `[T; Length]`

- `&String` 会被隐式地转换成 `&str` 类型

-  过长的元组无法被打印输出